<?xml version="1.0" encoding="utf-16"?>
<ZL_OBJECT CHECKSUM="6481B45ED139F9E01F4DBC11A391A798" CODE_SIGNATURE="29C853F854A1D6F98523AF69F4E6D024" CONNECTOR="39AC0A4B07A5A05AE1000000AC120173" NAME="YGPL_TABLES_SIZE" TYPE="CLAS" VERSION="1.01">
 <DEPENDENCIES>
  <ITEM TYPE="CLAS" NAME="YGPL_DS_ENGINE"/>
  <ITEM TYPE="CLAS" NAME="YGPL_TADIR_SEARCH"/>
 </DEPENDENCIES>
 <DIRECTORY DEVCLASS="YGPL-DBA" MASTERLANG="E"/>
 <RAW>
  <A0_MAINDATA VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" CLSCCINCL="X" FIXPT="X" UNICODE="X">
   <TEXTS>
    <ITEM LANG="E" TEXT="Table Size for Oracle">U1&amp;FUNCTIONALITY&amp;
ASAllow to activate (compile) a components.
U1&amp;RELATIONS&amp;
AS
U1&amp;EXAMPLE&amp;
AS
U1&amp;HINTS&amp;
AS
U1&amp;FURTHER_SOURCES_OF_INF&amp;
AS</ITEM>
   </TEXTS>
  </A0_MAINDATA>
  <ATTRIBUTS>
   <ITEM CMPNAME="CACHE_ID" EXPOSURE="1" STATE="1" ATTDECLTYP="2" ATTVALUE="&apos;88D9C44E0EA4270EE1000000AC1201D6&apos;" TYPTYPE="1" TYPE="YGPL_DS_ENGINE=&gt;TD_STORE_ID">
    <TEXTS>
     <ITEM LANG="E" TEXT="Table&apos;s Size Cache ID"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="CACHE_VALIDITY" EXPOSURE="1" STATE="1" ATTDECLTYP="2" ATTVALUE="7200" TYPTYPE="1" TYPE="YGPL_DS_ENGINE=&gt;TD_VALIDITY">
    <TEXTS>
     <ITEM LANG="E" TEXT="Cache validity Time (in sec) of cache : 2 heures"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="C_TABLE_COMPTYPE" EXPOSURE="1" STATE="1" ATTDECLTYP="2" ATTVALUE="&apos;TABL&apos;" TYPTYPE="1" TYPE="TD_COMPTYPE"/>
   <ITEM CMPNAME="DB_SIZE" EXPOSURE="2" STATE="1" ATTDECLTYP="1" ATTRDONLY="X" TYPTYPE="1" TYPE="TD_SIZE"/>
   <ITEM CMPNAME="INDEXES_LIST" EXPOSURE="2" STATE="1" ATTDECLTYP="1" TYPTYPE="1" TYPE="TT_TABLE_SIZE"/>
   <ITEM CMPNAME="RELEASE" EXPOSURE="2" STATE="1" ATTDECLTYP="1" ATTRDONLY="X" TYPTYPE="1" TYPE="ORACLE_RELEASE">
    <TEXTS>
     <ITEM LANG="E" TEXT="Oracle release"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TABLES_LIST" EXPOSURE="2" STATE="1" ATTDECLTYP="1" ATTRDONLY="X" TYPTYPE="1" TYPE="TT_TABLE_SIZE"/>
  </ATTRIBUTS>
  <DEFERRED>
   <CLASSES>
    <ITEM TYPEGROUP="YGPL_DS_ENGINE" TPUTYPE="1" EXPLICIT="X"/>
    <ITEM TYPEGROUP="YGPL_TADIR_SEARCH" TPUTYPE="1" EXPLICIT="X"/>
   </CLASSES>
  </DEFERRED>
  <LOCAL>
   <TYPES>`
*&quot;* USE THIS SOURCE FILE FOR ANY TYPE DECLARATIONS (CLASS
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* IMPLEMENTATION OR PRIVATE METHOD&apos;S SIGNATURE</TYPES>
   <IMPLEMENTATIONS>`
*&quot;* LOCAL CLASS IMPLEMENTATION FOR PUBLIC CLASS
*&quot;* use this source file for the implementation part of
*&quot;* LOCAL HELPER CLASSES</IMPLEMENTATIONS>
   <MACROS>`
*&quot;* USE THIS SOURCE FILE FOR ANY MACRO DEFINITIONS YOU NEED
*&quot;* IN THE IMPLEMENTATION PART OF THE CLASS</MACROS>
  </LOCAL>
  <METHODS>
   <ITEM CMPNAME="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" MTDTYPE="2" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="CLASS_CONSTRUCTOR"/>
    </TEXTS>
    <SOURCE>`
  DATA s_td110  TYPE td110_stru.
  DATA s_cache  TYPE ts_cache.

  ASSERT sy-dbsys(3) = &apos;ORA&apos;.

* Oracle Release
  CALL FUNCTION &apos;GET_DB_ORA_RELEASE&apos;
    IMPORTING
      oracle_release = release.

* DB Size
  CALL FUNCTION &apos;DB02_ORA_FILL_TD110&apos;
    IMPORTING
      td110 = s_td110.
  db_size = s_td110-tssi.

  TRY.
      CALL METHOD ygpl_ds_engine=&gt;get_from_cache
        EXPORTING
          id    = cache_id
        CHANGING
          value = s_cache.
      tables_list = s_cache-tables.
      indexes_list = s_cache-indexes.
      EXIT.
    CATCH ygpl_ds_cx_memory.
    CATCH ygpl_ds_cx_obsolete.
  ENDTRY.

* Table size
  compute_table_list( ).

* Table size
  compute_index_list( ).

  s_cache-tables = tables_list.
  s_cache-indexes = indexes_list.
  TRY.
      CALL METHOD ygpl_ds_engine=&gt;save_to_cache
        EXPORTING
          id       = cache_id
          value    = s_cache
          validity = cache_validity.
    CATCH ygpl_ds_cx_memory.
* Can&apos;t be saved in shared memory : too big ??
  ENDTRY.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="COMPUTE_INDEX_LIST" STATE="1" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Compute Index_list from Oracle DB"/>
    </TEXTS>
    <SOURCE>`
  DATA s_data   LIKE LINE OF indexes_list.
  DATA t_data   TYPE STANDARD TABLE OF ts_table_size WITH DEFAULT KEY.

  EXEC SQL.
    OPEN dbcur for
    select
      s.segment_name,
      sum( s.bytes/1024 ) mb
    from dba_segments s
    where s.owner like &apos;%SAP%&apos;
      and s.SEGMENT_TYPE like &apos;%INDEX%&apos;
      and s.segment_name like &apos;%~%&apos;
    group by s.segment_name
  ENDEXEC.
  DO.
    CLEAR s_data.
    EXEC SQL.
      FETCH NEXT dbcur INTO :s_data-table_name, :s_data-size
    ENDEXEC.
    IF sy-subrc &lt;&gt; 0.
      EXIT.
    ELSE.
      APPEND s_data TO t_data.
    ENDIF.
  ENDDO.

  EXEC SQL.
    CLOSE dbcur
  ENDEXEC.

  indexes_list = t_data.     &quot; standard table to hashed table</SOURCE>
   </ITEM>
   <ITEM CMPNAME="COMPUTE_TABLE_LIST" STATE="1" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Compute table_list from Oracle DB"/>
    </TEXTS>
    <SOURCE>`
  DATA s_data   LIKE LINE OF tables_list.
  DATA t_data   TYPE STANDARD TABLE OF ts_table_size WITH DEFAULT KEY.

  EXEC SQL.
    OPEN dbcur for
    select
/*      S.Owner,    */
      case
        when l.table_name is not null then l.table_name
        when i.table_name is not null then i.table_name
        when instr( s.segment_name, &apos;~&apos; ) = 0 then s.segment_name
        else substr( s.segment_name, 1, instr( s.segment_name, &apos;~&apos; ) - 1 )
      end Table_name
      , sum( s.bytes/1024 ) mb
    from dba_segments s, dba_lobs l, dba_lobs i
    where s.owner like &apos;%SAP%&apos;
      and l.owner(+) = s.owner
      and l.segment_name(+) = s.segment_name
      and i.owner(+) = s.owner
      and i.index_name(+) = s.segment_name
    group by
/*    S.Owner, */
      case
        when l.table_name is not null then l.table_name
        when i.table_name is not null then i.table_name
        when instr( s.segment_name, &apos;~&apos; ) = 0 then s.segment_name
        else substr( s.segment_name, 1, instr( s.segment_name, &apos;~&apos; ) - 1 )
      end
/*    order by sum( s.bytes/1024 ) desc*/
  ENDEXEC.
  DO.
    CLEAR s_data.
    EXEC SQL.
      FETCH NEXT dbcur INTO :s_data-table_name, :s_data-size
    ENDEXEC.
    IF sy-subrc &lt;&gt; 0.
      EXIT.
    ELSE.
      APPEND s_data TO t_data.
    ENDIF.
  ENDDO.

  EXEC SQL.
    CLOSE dbcur
  ENDEXEC.

  tables_list = t_data.     &quot; standard table to hashed table</SOURCE>
   </ITEM>
   <ITEM CMPNAME="CREATE_FILTER_FROM_LOWER_LIMIT" EXPOSURE="2" STATE="1" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Create size filter with lower limit"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="TR_SIZE">
      <TEXTS>
       <ITEM LANG="E" TEXT="Range of Size in KO"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="SIZE" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TD_SIZE">
      <TEXTS>
       <ITEM LANG="E" TEXT="lower limite Size in Ko"/>
      </TEXTS>
     </ITEM>
    </PARAMETERS>
    <SOURCE>`
  DATA s_size         LIKE LINE OF result.

  CHECK size &gt; 0.
  s_size-sign = &apos;I&apos;.
  s_size-option = &apos;GE&apos;.
  s_size-low = size.
  APPEND s_size TO result.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="FILTER_BY_TABLE_SIZE" EXPOSURE="2" STATE="1" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Keep only table with specific table size"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="LIST" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TT_COMPKEYS">
      <TEXTS>
       <ITEM LANG="E" TEXT="List of component keys"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="TT_COMPKEYS">
      <TEXTS>
       <ITEM LANG="E" TEXT="List of component keys"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="SIZE_FILTER" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TR_SIZE">
      <TEXTS>
       <ITEM LANG="E" TEXT="Range of Size in KO"/>
      </TEXTS>
     </ITEM>
    </PARAMETERS>
    <SOURCE>`
  DATA d_table_name   TYPE td_table_name.
  DATA d_table_size   TYPE td_size.
  FIELD-SYMBOLS: &lt;i&gt; LIKE LINE OF list.

  IF size_filter IS INITIAL.
    result = list.
  ELSE.
    LOOP AT list ASSIGNING &lt;i&gt;.
      IF &lt;i&gt;-type = c_table_comptype.
        d_table_name = &lt;i&gt;-name.
        d_table_size = get_table_size( d_table_name ).
        CHECK d_table_size IN size_filter.
      ENDIF.
      APPEND &lt;i&gt; TO result.
    ENDLOOP.
  ENDIF.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="FILTER_TABLE" EXPOSURE="2" STATE="1" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Keep only Table in Component list"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="LIST" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TT_COMPKEYS">
      <TEXTS>
       <ITEM LANG="E" TEXT="List of component keys"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="TT_COMPKEYS">
      <TEXTS>
       <ITEM LANG="E" TEXT="List of component keys"/>
      </TEXTS>
     </ITEM>
    </PARAMETERS>
    <SOURCE>`
  TYPES:
    BEGIN OF ts_table,
      name TYPE td_table_name,
    END OF ts_table.
  DATA t_tables       TYPE STANDARD TABLE OF ts_table WITH DEFAULT KEY.
  DATA s_table        LIKE LINE OF t_tables.
  DATA s_line         LIKE LINE OF result.
  FIELD-SYMBOLS:
    &lt;i&gt; LIKE LINE OF list.

  LOOP AT list ASSIGNING &lt;i&gt;
       WHERE type = c_table_comptype.
    CLEAR s_table.
    s_table-name = &lt;i&gt;-name.
    APPEND s_table TO t_tables.
  ENDLOOP.

* Get tables only (remove structures)
  SELECT tabname AS name
    INTO CORRESPONDING FIELDS OF TABLE result
    FROM dd02l
    FOR ALL ENTRIES IN t_tables
    WHERE tabname = t_tables-name
      AND tabclass = &apos;TRANSP&apos;
    %_HINTS ORACLE &apos;&amp;max_in_blocking_factor 200&amp;&apos; .

  s_line-type = c_table_comptype.
  MODIFY result FROM s_line TRANSPORTING type WHERE type IS INITIAL.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="GET_INDEX_SIZE" EXPOSURE="2" STATE="1" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Get Index Size"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="INDEX_NAME" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TD_INDEX_NAME">
      <TEXTS>
       <ITEM LANG="E" TEXT="Unique Index ID in a Table"/>
      </TEXTS>
     </ITEM>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="TD_SIZE"/>
     <ITEM SCONAME="TABLE_NAME" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TD_TABLE_NAME"/>
    </PARAMETERS>
    <SOURCE>`
  DATA s_idxdb_name TYPE dd12l-dbindex.
  DATA s_subrc      TYPE sy-subrc.
  FIELD-SYMBOLS: &lt;i&gt; LIKE LINE OF indexes_list.

  CALL FUNCTION &apos;DB_EXISTS_INDEX&apos;
    EXPORTING
*      DBINDEX               =
      tabname               = table_name
      indexname             = index_name
    IMPORTING
*     CONSTRAINT            =
      realname              = s_idxdb_name
      subrc                 = s_subrc
*     UNIQUE                =
    EXCEPTIONS
      parameter_error       = 1
      OTHERS                = 2.
  ASSERT sy-subrc = 0.
  CHECK s_subrc = 0.

  READ TABLE indexes_list ASSIGNING &lt;i&gt;
       WITH TABLE KEY table_name = s_idxdb_name.
  CHECK sy-subrc = 0.
  result = &lt;i&gt;-size.
*  EXEC SQL.
*    SELECT bytes / 1024 into :result
*      FROM dba_segments
*      where segment_name = :s_idxdb_name
*  ENDEXEC.</SOURCE>
   </ITEM>
   <ITEM CMPNAME="GET_TABLE_SIZE" EXPOSURE="2" STATE="1" MTDDECLTYP="1">
    <TEXTS>
     <ITEM LANG="E" TEXT="Get Table Size"/>
    </TEXTS>
    <PARAMETERS>
     <ITEM SCONAME="RESULT" CMPTYPE="1" PARDECLTYP="3" TYPTYPE="1" TYPE="TD_SIZE"/>
     <ITEM SCONAME="TABLE_NAME" CMPTYPE="1" PARPASSTYP="1" TYPTYPE="1" TYPE="TD_TABLE_NAME"/>
    </PARAMETERS>
    <SOURCE>`
  FIELD-SYMBOLS &lt;s&gt; LIKE LINE OF tables_list.
  READ TABLE tables_list ASSIGNING &lt;s&gt;
       WITH TABLE KEY table_name = table_name.
  CHECK sy-subrc = 0.
  result = &lt;s&gt;-size.</SOURCE>
   </ITEM>
  </METHODS>
  <TYPEGROUPS>
   <ITEM TYPEGROUP="ABAP" EXPLICIT="X"/>
   <ITEM TYPEGROUP="SEWOR" EXPLICIT="X"/>
   <ITEM TYPEGROUP="SWBM" EXPLICIT="X"/>
  </TYPEGROUPS>
  <TYPES>
   <ITEM CMPNAME="TD_COMPTYPE" EXPOSURE="1" STATE="1" EDITORDER="1 " TYPTYPE="1" TYPE="YGPL_TADIR_SEARCH=&gt;TD_COMPTYPE"/>
   <ITEM CMPNAME="TD_INDEX_NAME" EXPOSURE="2" STATE="1" EDITORDER="1 " TYPTYPE="1" TYPE="INDEXID">
    <TEXTS>
     <ITEM LANG="E" TEXT="Unique Index ID in a Table"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TD_SIZE" EXPOSURE="2" STATE="1" EDITORDER="4 " TYPTYPE="1" TYPE="I">
    <TEXTS>
     <ITEM LANG="E" TEXT="Size in Ko"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TD_TABLE_NAME" EXPOSURE="2" STATE="1" EDITORDER="3 " TYPTYPE="4">td_table_name(30) TYPE c
`</ITEM>
   <ITEM CMPNAME="TR_SIZE" EXPOSURE="2" STATE="1" EDITORDER="5 " TYPTYPE="4">
    tr_size TYPE RANGE OF td_size
`
    <TEXTS>
     <ITEM LANG="E" TEXT="Range of Size in KO"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TS_CACHE" EXPOSURE="1" STATE="1" EDITORDER="2 " TYPTYPE="4">begin of ts_cache,
      tables    type tt_table_size,
      indexes   type tt_table_size,
    end of ts_cache
`</ITEM>
   <ITEM CMPNAME="TS_TABLE_SIZE" EXPOSURE="2" STATE="1" EDITORDER="6 " TYPTYPE="4">BEGIN OF ts_table_size,
        table_name    TYPE string,      &quot; td_table_name,
        size          TYPE td_size,
      END OF ts_table_size
`</ITEM>
   <ITEM CMPNAME="TT_COMPKEYS" EXPOSURE="2" STATE="1" EDITORDER="2 " TYPTYPE="1" TYPE="YGPL_TADIR_SEARCH=&gt;TT_COMPKEYS">
    <TEXTS>
     <ITEM LANG="E" TEXT="List of component keys"/>
    </TEXTS>
   </ITEM>
   <ITEM CMPNAME="TT_TABLE_SIZE" EXPOSURE="2" STATE="1" EDITORDER="7 " TYPTYPE="4">tt_table_size TYPE HASHED TABLE OF ts_table_size WITH UNIQUE KEY table_name
`</ITEM>
  </TYPES>
 </RAW>
</ZL_OBJECT>
